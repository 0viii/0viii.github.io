<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Flappy Phaser - M칩vil</title>
  <style>
    html,body { height:100%; margin:0; background:#87CEEB; } /* cielo */
    #game-container { width:100%; height:100vh; display:flex; align-items:center; justify-content:center; }
    /* Opcional: mensaje peque침o abajo */
    .hint { position: absolute; bottom: 8px; width:100%; text-align:center; font-family: Arial, sans-serif; color:#033; pointer-events:none; }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <div class="hint">Toca la pantalla o pulsa ESPACIO para volar 九걾잺</div>

  <!-- Phaser 3 (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

  <script>
    // Configuraci칩n del juego (responsive)
    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      width: 480,           // resoluci칩n base (escalar치)
      height: 640,
      backgroundColor: 0x87CEEB, // mismo color que body
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 900 }, // gravedad principal
          debug: false
        }
      },
      scene: {
        preload,
        create,
        update
      }
    };

    const game = new Phaser.Game(config);

    function preload() {
      // generamos texturas simples (p치jaro y tubo) con graphics para que no dependamos de im치genes externas
      // P치jaro: c칤rculo amarillo
      this.graphics = this.add.graphics();
      this.graphics.fillStyle(0xFFDD33, 1);
      this.graphics.fillCircle(16, 16, 16);
      this.graphics.generateTexture('bird', 32, 32);
      this.graphics.clear();

      // Tubo: rect치ngulo verde
      this.graphics.fillStyle(0x2E8B57, 1);
      this.graphics.fillRect(0, 0, 52, 400);
      this.graphics.generateTexture('pipe', 52, 400);
      this.graphics.clear();

      // Suelo para colisi칩n (invisible)
      this.graphics.fillStyle(0x000000, 1);
      this.graphics.fillRect(0, 0, 10, 10);
      this.graphics.generateTexture('pixel', 1, 1);
      this.graphics.destroy();
    }

    function create() {
      const scene = this;

      // Variables del juego
      this.gameSpeed = 160;      // velocidad de los tubos
      this.pipeGap = 150;        // hueco entre tubos
      this.pipeInterval = 1400;  // ms entre tubos (se puede ajustar)
      this.isRunning = false;
      this.score = 0;

      // Fondo simple con nube/monta침a (opcional): solo color ya usado

      // Suelo (para choque)
      this.ground = this.physics.add.staticGroup();
      // un rect치ngulo invisible al fondo que hace de suelo
      const groundHeight = 24;
      this.ground.create(config.width/2, config.height - groundHeight/2, 'pixel').setScale(config.width, groundHeight).refreshBody().setVisible(false);

      // P치jaro
      this.bird = this.physics.add.sprite(100, config.height / 2, 'bird');
      this.bird.setCollideWorldBounds(true);
      this.bird.setCircle(14);             // colisi칩n circular
      this.bird.setBounce(0);              // nada de rebote
      this.bird.body.setAllowGravity(true);
      this.bird.setDepth(2);

      // Grupo de tubos
      this.pipes = this.physics.add.group();

      // Colisiones: con suelo o tubos => fin
      this.physics.add.collider(this.bird, this.ground, hitPipeOrGround, null, this);
      this.physics.add.overlap(this.bird, this.pipes, hitPipeOrGround, null, this);

      // Input: cuando tocas o presionas
      this.input.on('pointerdown', flap, this);
      this.input.keyboard.on('keydown-SPACE', flap, this);

      // Texto score
      this.scoreText = this.add.text(20, 20, 'Puntos: 0', { font: '22px Arial', fill: '#033' }).setDepth(3);

      // Mensaje inicio
      this.startText = this.add.text(config.width/2, config.height/2 - 40, 'Toca para empezar', { font: '28px Arial', fill: '#033' }).setOrigin(0.5);

      // Temporizador para crear tubos (lo activamos al iniciar)
      this.pipeTimer = null;

      // Ajuste en resize: cuando el canvas se escala, las f칤sicas siguen la resoluci칩n base (480x640),
      // por eso posicionamos elementos basados en config.width/config.height.
      // Reinicio por defecto
      this.gameOver = false;

      // Para un movimiento m치s suave rotamos el p치jaro seg칰n su velocidad
      this.birdRotationTween = null;

      // funci칩n auxiliar: iniciar el juego
      this.startGame = function() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.startText.setVisible(false);
        this.score = 0;
        this.scoreText.setText('Puntos: 0');
        this.bird.setPosition(100, config.height/2);
        this.bird.setVelocity(0, 0);
        this.bird.setActive(true);
        this.bird.setAngularVelocity(0);
        this.gameOver = false;

        // eliminar tubos antiguos
        this.pipes.clear(true, true);

        // generar tubos peri칩dicamente
        this.pipeTimer = this.time.addEvent({
          delay: this.pipeInterval,
          callback: spawnPipes,
          callbackScope: this,
          loop: true
        });
      }.bind(this);

      // funci칩n para terminar el juego
      function hitPipeOrGround() {
        if (scene.gameOver) return;
        scene.gameOver = true;
        scene.isRunning = false;
        // detener tubos
        if (scene.pipeTimer) scene.pipeTimer.remove(false);
        // congelar tubos existentes
        scene.pipes.children.iterate(pipe => {
          pipe.body.setVelocityX(0);
        });
        // detener el p치jaro
        scene.bird.setTint(0xff4444);
        scene.bird.body.setVelocityY(0);
        scene.bird.body.setAllowGravity(false);

        // mensaje de reinicio
        scene.time.delayedCall(300, () => {
          const restartText = scene.add.text(config.width/2, config.height/2, 'Perdiste 游땩\nToca para reiniciar', { font: '26px Arial', fill: '#033', align: 'center' }).setOrigin(0.5);
          restartText.setDepth(5);
          scene.input.once('pointerdown', () => {
            restartText.destroy();
            scene.startText.setVisible(true);
            scene.bird.clearTint();
            scene.physics.world.gravity.y = 900;
            scene.startGame();
          }, scene);
        });
      }

      // flapp (salto)
      function flap() {
        // si no empez칩, iniciamos
        if (!scene.isRunning) {
          scene.startGame();
        }
        if (scene.gameOver) return;
        // impulso hacia arriba
        scene.bird.setVelocityY(-330);
        // rotaci칩n r치pida hacia arriba
        scene.tweens.killTweensOf(scene.bird);
        scene.tweens.add({
          targets: scene.bird,
          angle: -20,
          duration: 100,
          ease: 'Power1'
        });
      }

      // crear tubos
      function spawnPipes() {
        const gap = scene.pipeGap;
        const pipeTopHeight = Phaser.Math.Between(50, config.height - gap - 120);
        const pipeX = config.width + 30;

        // tubo superior (invertido)
        const top = scene.pipes.create(pipeX, pipeTopHeight - 200, 'pipe').setOrigin(0, 1);
        top.body.allowGravity = false;
        top.body.immovable = true;
        top.body.setVelocityX(-scene.gameSpeed - Phaser.Math.Between(0, 30));

        // tubo inferior
        const bottomY = pipeTopHeight + gap;
        const bottom = scene.pipes.create(pipeX, bottomY + 200, 'pipe').setOrigin(0, 0);
        bottom.body.allowGravity = false;
        bottom.body.immovable = true;
        bottom.body.setVelocityX(-scene.gameSpeed - Phaser.Math.Between(0, 30));

        // marcar cuando el p치jaro pasa entre tubos para aumentar score
        // usaremos una zona invisible entre tubos
        const scoreZone = scene.add.zone(pipeX + 26, pipeTopHeight + gap/2, 2, gap);
        scene.physics.world.enable(scoreZone);
        scoreZone.body.allowGravity = false;
        scoreZone.body.setVelocityX(-scene.gameSpeed - 30);
        scoreZone.scored = false;

        // overlap entre p치jaro y zone -> sumar puntos
        scene.physics.add.overlap(scene.bird, scoreZone, function(bird, zone) {
          if (!zone.scored && !scene.gameOver) {
            zone.scored = true;
            scene.score++;
            scene.scoreText.setText('Puntos: ' + scene.score);
          }
        });

        // limpiar tubos fuera de pantalla regularmente
        // (tubos y scoreZone se eliminar치n en update cuando x < -100)
      }

      // limpia objetos que salieron de pantalla
      this.cleanup = function() {
        this.pipes.children.iterate(pipe => {
          if (pipe.x < -100) {
            pipe.destroy();
          }
        });
        // limpiar zonas (no son parte del grupo)
        this.children.list.forEach(child => {
          if (child.body && child.body.velocity && child.x < -200 && child.width > 2 && child.height > 2 && child.texture.key === '__DEFAULT') {
            // ignore
          }
        });
      };
    }

    function update(time, delta) {
      // inclinaci칩n natural hacia abajo
      if (this.isRunning && !this.gameOver) {
        // rotar en funci칩n de la velocidad Y
        const velY = this.bird.body.velocity.y;
        const targetAngle = Phaser.Math.Clamp((velY / 600) * 90, -20, 60);
        this.bird.angle = Phaser.Math.Interpolation.Linear([this.bird.angle, targetAngle], 0.1);
      }

      // desmontar objetos viejos (pipes y zones)
      // buscar pipes y zones que est칠n fuera de la pantalla y destruirlos
      this.pipes.children.iterate(pipe => {
        if (pipe && pipe.x < -100) pipe.destroy();
      });

      // tambi칠n destruimos zonas (objetos con body y size peque침a)
      this.children.list.forEach(child => {
        if (child && child.body && child.body.velocity && child.x < -100 && (child.width <= 4 || child.height <= 4)) {
          child.destroy();
        }
      });

      // Si no se inici칩, el p치jaro puede moverse ligeramente (lean) para verse vivo
      if (!this.isRunning && !this.gameOver) {
        // leve flotaci칩n
        this.bird.y = config.height/2 + Math.sin(time / 400) * 8;
      }
    }
  </script>
</body>
</html>

